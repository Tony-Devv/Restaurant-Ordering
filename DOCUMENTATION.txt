Restaurant Ordering & Billing System — Design Decisions and Rationale

1. Overview
This document explains the architecture, main components, applied design patterns, and SOLID principles for the Restaurant Ordering & Billing System. The codebase is modular and designed for extension and maintainability.

2. High-level architecture
- Facade (RestaurantFacade): single entry point for the ordering workflow (display menu, create order, notify kitchen, billing & payment).
- Domain entities: Order, MenuItem and concrete base items (BasePizza, BaseBurger, BaseDessert, BaseBeverage).
- Customization: AddOnDecorator and concrete decorators (ExtraCheese, Mushrooms, Olives, SpicySauce, BBQSauce).
- Menu creation: Abstract Factory (MenuFactory) for menu families, and Factory Method (PizzaFactory, BurgerFactory) for specific pizzas/burgers.
- Notification: OrderNotifier (subject) and KitchenDisplay/WaiterDisplay (observers).
- Billing: BillingService, TaxCalculator, and Bill.
- Payment: PaymentStrategy implementations: CashPayment, CardPayment, MobileWalletPayment.
- Discounts: DiscountStrategy implementations (PizzaDiscount, MeatDiscount, ChickenDiscount) and DiscountFactory to create strategies.

3. Design Patterns — Mapping and Purpose

3.1 Facade Pattern
    Classes: RestaurantFacade
    Why used:
      - Simplifies a complex workflow (menu → order → notify kitchen → billing → payment).
      - Shields the client from the complexity of multiple subsystems.
      - Reduces coupling between UI/driver code and business logic.
      - Ideal for a simulated console or future GUI.

3.2 Observer Pattern
    Classes: 
      - Subject: OrderNotifier
      - Observer: OrderObserver
      - Concrete Observers: KitchenDisplay, WaiterDisplay
    Why used:
      - Simplifies a complex workflow (menu → order → notify kitchen → billing → payment).
      - Shields the client from the complexity of multiple subsystems.
      - Reduces coupling between UI/driver code and business logic.
      - Ideal for a simulated console or future GUI.

3.3 Decorator Pattern
    Classes: 
      - AddOnDecorator
      - Concrete decorators: ExtraCheese, Mushrooms, Olives, etc.
    Why used:
      - Allows dynamic and flexible customization of menu items (add-ons).
      - Supports unlimited combinations of toppings without exploding the number of subclasses.
      - Preserves Open/Closed Principle — add-ons are added via new classes, not by editing existing menu items.
      - Perfect fit for “add topping” or “add ingredient” behavior.

3.4 Abstract Factory Pattern
    Classes: 
      - MenuFactory
      - Concrete factories for menu families (e.g., ItalianMenuFactory, AmericanMenuFactory)
    Why used:
      - Restaurants often have different families of menus (Italian, Kids Menu, Breakfast Menu).
      - Ensures consistency between related items (e.g., an Italian factory creates Italian pizzas, Italian desserts…).
      - Helps create "product families" without coupling client code to concrete classes.

3.5 Factory Method Pattern
    Classes: 
      - PizzaFactory
      - BurgerFactory
    Why used:
      - Allows subclasses to decide which specific pizza or burger object to create.
      - Avoids having large switch statements or if-else chains.
      - Makes it easy to add new pizza/burger types while keeping creator logic isolated.

3.6 Strategy Pattern
  Used twice:
    DiscountStrategy
      Classes: 
        - DiscountStrategy, PizzaDiscount, MeatDiscount, ChickenDiscount
      Why used:
        - Different discount rules apply to different food categories.
        - Allows changing the discount algorithm without changing billing logic.
        - Enables combining strategies via a DiscountFactory.

     PaymentStrategy
      Classes: 
        - PaymentStrategy, CashPayment, CardPayment, MobileWalletPayment
      Why used:
        - Payment behavior varies widely depending on method.
        - Keeps payment logic interchangeable and loosely coupled.
        - Extensible for future payments (PayPal, crypto, reward points…).

4. SOLID principles & justification
- Single Responsibility: each class has a single responsibility (TaxCalculator only computes tax, BillingService handles billing).
- Open/Closed: new menu families, discount rules, payment methods, or add-ons can be added by creating new classes without changing existing code.
- Liskov Substitution: concrete MenuItem and decorators can be used where MenuItem is expected.
- Interface Segregation: small focused interfaces.
- Dependency Inversion: high-level modules depend on abstractions.

5. Extension points
- New menu family: implement MenuFactory.
- New pizza/burger type: extend PizzaFactory.
- New add-on: implement AddOnDecorator.
- New discount rule: implement DiscountStrategy.
- New payment method: implement PaymentStrategy.

6. Notes and caveats
- Order.quantities maps by object identity; implement equals/hashCode on base items for logical equality if needed.
- Console-based simulation; separate UI and business logic for production systems.
- Payment simulation: payments are mocked (no real gateway).

End of document.
